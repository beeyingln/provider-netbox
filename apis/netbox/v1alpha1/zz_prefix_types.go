/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PrefixObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type PrefixParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	IsPool *bool `json:"isPool,omitempty" tf:"is_pool,omitempty"`

	// +kubebuilder:validation:Optional
	MarkUtilized *bool `json:"markUtilized,omitempty" tf:"mark_utilized,omitempty"`

	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	RoleID *float64 `json:"roleId,omitempty" tf:"role_id,omitempty"`

	// +kubebuilder:validation:Optional
	SiteID *float64 `json:"siteId,omitempty" tf:"site_id,omitempty"`

	// +kubebuilder:validation:Required
	Status *string `json:"status" tf:"status,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TenantID *float64 `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`

	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// +kubebuilder:validation:Optional
	VrfID *float64 `json:"vrfId,omitempty" tf:"vrf_id,omitempty"`
}

// PrefixSpec defines the desired state of Prefix
type PrefixSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PrefixParameters `json:"forProvider"`
}

// PrefixStatus defines the observed state of Prefix.
type PrefixStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PrefixObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Prefix is the Schema for the Prefixs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,netboxjet}
type Prefix struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PrefixSpec   `json:"spec"`
	Status            PrefixStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PrefixList contains a list of Prefixs
type PrefixList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Prefix `json:"items"`
}

// Repository type metadata.
var (
	Prefix_Kind             = "Prefix"
	Prefix_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Prefix_Kind}.String()
	Prefix_KindAPIVersion   = Prefix_Kind + "." + CRDGroupVersion.String()
	Prefix_GroupVersionKind = CRDGroupVersion.WithKind(Prefix_Kind)
)

func init() {
	SchemeBuilder.Register(&Prefix{}, &PrefixList{})
}
